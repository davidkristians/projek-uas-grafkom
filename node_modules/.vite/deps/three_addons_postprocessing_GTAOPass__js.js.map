{
  "version": 3,
  "sources": ["../../three/examples/jsm/shaders/GTAOShader.js", "../../three/examples/jsm/shaders/PoissonDenoiseShader.js", "../../three/examples/jsm/math/SimplexNoise.js", "../../three/examples/jsm/postprocessing/GTAOPass.js"],
  "sourcesContent": ["import {\r\n\tDataTexture,\r\n\tMatrix4,\r\n\tRepeatWrapping,\r\n\tVector2,\r\n\tVector3,\r\n} from 'three';\r\n\r\n/**\r\n * @module GTAOShader\r\n * @three_import import { GTAOShader } from 'three/addons/shaders/GTAOShader.js';\r\n */\r\n\r\n/**\r\n * GTAO shader. Use by {@link GTAOPass}.\r\n *\r\n * References:\r\n * - [Practical Realtime Strategies for Accurate Indirect Occlusion](https://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf).\r\n * - [Horizon-Based Indirect Lighting (HBIL)](https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf)\r\n *\r\n * @constant\r\n * @type {ShaderMaterial~Shader}\r\n */\r\nconst GTAOShader = {\r\n\r\n\tname: 'GTAOShader',\r\n\r\n\tdefines: {\r\n\t\tPERSPECTIVE_CAMERA: 1,\r\n\t\tSAMPLES: 16,\r\n\t\tNORMAL_VECTOR_TYPE: 1,\r\n\t\tDEPTH_SWIZZLING: 'x',\r\n\t\tSCREEN_SPACE_RADIUS: 0,\r\n\t\tSCREEN_SPACE_RADIUS_SCALE: 100.0,\r\n\t\tSCENE_CLIP_BOX: 0,\r\n\t},\r\n\r\n\tuniforms: {\r\n\t\ttNormal: { value: null },\r\n\t\ttDepth: { value: null },\r\n\t\ttNoise: { value: null },\r\n\t\tresolution: { value: new Vector2() },\r\n\t\tcameraNear: { value: null },\r\n\t\tcameraFar: { value: null },\r\n\t\tcameraProjectionMatrix: { value: new Matrix4() },\r\n\t\tcameraProjectionMatrixInverse: { value: new Matrix4() },\r\n\t\tcameraWorldMatrix: { value: new Matrix4() },\r\n\t\tradius: { value: 0.25 },\r\n\t\tdistanceExponent: { value: 1. },\r\n\t\tthickness: { value: 1. },\r\n\t\tdistanceFallOff: { value: 1. },\r\n\t\tscale: { value: 1. },\r\n\t\tsceneBoxMin: { value: new Vector3( - 1, - 1, - 1 ) },\r\n\t\tsceneBoxMax: { value: new Vector3( 1, 1, 1 ) },\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform highp sampler2D tNormal;\r\n\t\tuniform highp sampler2D tDepth;\r\n\t\tuniform sampler2D tNoise;\r\n\t\tuniform vec2 resolution;\r\n\t\tuniform float cameraNear;\r\n\t\tuniform float cameraFar;\r\n\t\tuniform mat4 cameraProjectionMatrix;\r\n\t\tuniform mat4 cameraProjectionMatrixInverse;\r\n\t\tuniform mat4 cameraWorldMatrix;\r\n\t\tuniform float radius;\r\n\t\tuniform float distanceExponent;\r\n\t\tuniform float thickness;\r\n\t\tuniform float distanceFallOff;\r\n\t\tuniform float scale;\r\n\t\t#if SCENE_CLIP_BOX == 1\r\n\t\t\tuniform vec3 sceneBoxMin;\r\n\t\t\tuniform vec3 sceneBoxMax;\r\n\t\t#endif\r\n\r\n\t\t#include <common>\r\n\t\t#include <packing>\r\n\r\n\t\t#ifndef FRAGMENT_OUTPUT\r\n\t\t#define FRAGMENT_OUTPUT vec4(vec3(ao), 1.)\r\n\t\t#endif\r\n\r\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth) {\r\n\t\t\tvec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);\r\n\t\t\tvec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;\r\n\t\t\treturn viewSpacePosition.xyz / viewSpacePosition.w;\r\n\t\t}\r\n\r\n\t\tfloat getDepth(const vec2 uv) {\r\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).DEPTH_SWIZZLING;\r\n\t\t}\r\n\r\n\t\tfloat fetchDepth(const ivec2 uv) {\r\n\t\t\treturn texelFetch(tDepth, uv.xy, 0).DEPTH_SWIZZLING;\r\n\t\t}\r\n\r\n\t\tfloat getViewZ(const in float depth) {\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\t\t\t\treturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\r\n\t\t\t#else\r\n\t\t\t\treturn orthographicDepthToViewZ(depth, cameraNear, cameraFar);\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tvec3 computeNormalFromDepth(const vec2 uv) {\r\n\t\t\tvec2 size = vec2(textureSize(tDepth, 0));\r\n\t\t\tivec2 p = ivec2(uv * size);\r\n\t\t\tfloat c0 = fetchDepth(p);\r\n\t\t\tfloat l2 = fetchDepth(p - ivec2(2, 0));\r\n\t\t\tfloat l1 = fetchDepth(p - ivec2(1, 0));\r\n\t\t\tfloat r1 = fetchDepth(p + ivec2(1, 0));\r\n\t\t\tfloat r2 = fetchDepth(p + ivec2(2, 0));\r\n\t\t\tfloat b2 = fetchDepth(p - ivec2(0, 2));\r\n\t\t\tfloat b1 = fetchDepth(p - ivec2(0, 1));\r\n\t\t\tfloat t1 = fetchDepth(p + ivec2(0, 1));\r\n\t\t\tfloat t2 = fetchDepth(p + ivec2(0, 2));\r\n\t\t\tfloat dl = abs((2.0 * l1 - l2) - c0);\r\n\t\t\tfloat dr = abs((2.0 * r1 - r2) - c0);\r\n\t\t\tfloat db = abs((2.0 * b1 - b2) - c0);\r\n\t\t\tfloat dt = abs((2.0 * t1 - t2) - c0);\r\n\t\t\tvec3 ce = getViewPosition(uv, c0).xyz;\r\n\t\t\tvec3 dpdx = (dl < dr) ? ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;\r\n\t\t\tvec3 dpdy = (db < dt) ? ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;\r\n\t\t\treturn normalize(cross(dpdx, dpdy));\r\n\t\t}\r\n\r\n\t\tvec3 getViewNormal(const vec2 uv) {\r\n\t\t\t#if NORMAL_VECTOR_TYPE == 2\r\n\t\t\t\treturn normalize(textureLod(tNormal, uv, 0.).rgb);\r\n\t\t\t#elif NORMAL_VECTOR_TYPE == 1\r\n\t\t\t\treturn unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);\r\n\t\t\t#else\r\n\t\t\t\treturn computeNormalFromDepth(uv);\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tvec3 getSceneUvAndDepth(vec3 sampleViewPos) {\r\n\t\t\tvec4 sampleClipPos = cameraProjectionMatrix * vec4(sampleViewPos, 1.);\r\n\t\t\tvec2 sampleUv = sampleClipPos.xy / sampleClipPos.w * 0.5 + 0.5;\r\n\t\t\tfloat sampleSceneDepth = getDepth(sampleUv);\r\n\t\t\treturn vec3(sampleUv, sampleSceneDepth);\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\t\t\tfloat depth = getDepth(vUv.xy);\r\n\t\t\tif (depth >= 1.0) {\r\n\t\t\t\tdiscard;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvec3 viewPos = getViewPosition(vUv, depth);\r\n\t\t\tvec3 viewNormal = getViewNormal(vUv);\r\n\r\n\t\t\tfloat radiusToUse = radius;\r\n\t\t\tfloat distanceFalloffToUse = thickness;\r\n\t\t\t#if SCREEN_SPACE_RADIUS == 1\r\n\t\t\t\tfloat radiusScale = getViewPosition(vec2(0.5 + float(SCREEN_SPACE_RADIUS_SCALE) / resolution.x, 0.0), depth).x;\r\n\t\t\t\tradiusToUse *= radiusScale;\r\n\t\t\t\tdistanceFalloffToUse *= radiusScale;\r\n\t\t\t#endif\r\n\r\n\t\t\t#if SCENE_CLIP_BOX == 1\r\n\t\t\t\tvec3 worldPos = (cameraWorldMatrix * vec4(viewPos, 1.0)).xyz;\r\n\t\t\t\tfloat boxDistance = length(max(vec3(0.0), max(sceneBoxMin - worldPos, worldPos - sceneBoxMax)));\r\n\t\t\t\tif (boxDistance > radiusToUse) {\r\n\t\t\t\t\tdiscard;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\r\n\t\t\tvec2 noiseResolution = vec2(textureSize(tNoise, 0));\r\n\t\t\tvec2 noiseUv = vUv * resolution / noiseResolution;\r\n\t\t\tvec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);\r\n\t\t\tvec3 randomVec = noiseTexel.xyz * 2.0 - 1.0;\r\n\t\t\tvec3 tangent = normalize(vec3(randomVec.xy, 0.));\r\n\t\t\tvec3 bitangent = vec3(-tangent.y, tangent.x, 0.);\r\n\t\t\tmat3 kernelMatrix = mat3(tangent, bitangent, vec3(0., 0., 1.));\r\n\r\n\t\t\tconst int DIRECTIONS = SAMPLES < 30 ? 3 : 5;\r\n\t\t\tconst int STEPS = (SAMPLES + DIRECTIONS - 1) / DIRECTIONS;\r\n\t\t\tfloat ao = 0.0;\r\n\t\t\tfor (int i = 0; i < DIRECTIONS; ++i) {\r\n\r\n\t\t\t\tfloat angle = float(i) / float(DIRECTIONS) * PI;\r\n\t\t\t\tvec4 sampleDir = vec4(cos(angle), sin(angle), 0., 0.5 + 0.5 * noiseTexel.w);\r\n\t\t\t\tsampleDir.xyz = normalize(kernelMatrix * sampleDir.xyz);\r\n\r\n\t\t\t\tvec3 viewDir = normalize(-viewPos.xyz);\r\n\t\t\t\tvec3 sliceBitangent = normalize(cross(sampleDir.xyz, viewDir));\r\n\t\t\t\tvec3 sliceTangent = cross(sliceBitangent, viewDir);\r\n\t\t\t\tvec3 normalInSlice = normalize(viewNormal - sliceBitangent * dot(viewNormal, sliceBitangent));\r\n\r\n\t\t\t\tvec3 tangentToNormalInSlice = cross(normalInSlice, sliceBitangent);\r\n\t\t\t\tvec2 cosHorizons = vec2(dot(viewDir, tangentToNormalInSlice), dot(viewDir, -tangentToNormalInSlice));\r\n\r\n\t\t\t\tfor (int j = 0; j < STEPS; ++j) {\r\n\t\t\t\t\tvec3 sampleViewOffset = sampleDir.xyz * radiusToUse * sampleDir.w * pow(float(j + 1) / float(STEPS), distanceExponent);\r\n\r\n\t\t\t\t\tvec3 sampleSceneUvDepth = getSceneUvAndDepth(viewPos + sampleViewOffset);\r\n\t\t\t\t\tvec3 sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\r\n\t\t\t\t\tvec3 viewDelta = sampleSceneViewPos - viewPos;\r\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\r\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\r\n\t\t\t\t\t\tcosHorizons.x += max(0., (sampleCosHorizon - cosHorizons.x) * mix(1., 2. / float(j + 2), distanceFallOff));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsampleSceneUvDepth = getSceneUvAndDepth(viewPos - sampleViewOffset);\r\n\t\t\t\t\tsampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);\r\n\t\t\t\t\tviewDelta = sampleSceneViewPos - viewPos;\r\n\t\t\t\t\tif (abs(viewDelta.z) < thickness) {\r\n\t\t\t\t\t\tfloat sampleCosHorizon = dot(viewDir, normalize(viewDelta));\r\n\t\t\t\t\t\tcosHorizons.y += max(0., (sampleCosHorizon - cosHorizons.y) * mix(1., 2. / float(j + 2), distanceFallOff));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec2 sinHorizons = sqrt(1. - cosHorizons * cosHorizons);\r\n\t\t\t\tfloat nx = dot(normalInSlice, sliceTangent);\r\n\t\t\t\tfloat ny = dot(normalInSlice, viewDir);\r\n\t\t\t\tfloat nxb = 1. / 2. * (acos(cosHorizons.y) - acos(cosHorizons.x) + sinHorizons.x * cosHorizons.x - sinHorizons.y * cosHorizons.y);\r\n\t\t\t\tfloat nyb = 1. / 2. * (2. - cosHorizons.x * cosHorizons.x - cosHorizons.y * cosHorizons.y);\r\n\t\t\t\tfloat occlusion = nx * nxb + ny * nyb;\r\n\t\t\t\tao += occlusion;\r\n\t\t\t}\r\n\r\n\t\t\tao = clamp(ao / float(DIRECTIONS), 0., 1.);\r\n\t\t#if SCENE_CLIP_BOX == 1\r\n\t\t\tao = mix(ao, 1., smoothstep(0., radiusToUse, boxDistance));\r\n\t\t#endif\r\n\t\t\tao = pow(ao, scale);\r\n\r\n\t\t\tgl_FragColor = FRAGMENT_OUTPUT;\r\n\t\t}`\r\n\r\n};\r\n\r\n/**\r\n * GTAO depth shader. Use by {@link GTAOPass}.\r\n *\r\n * @constant\r\n * @type {Object}\r\n */\r\nconst GTAODepthShader = {\r\n\r\n\tname: 'GTAODepthShader',\r\n\r\n\tdefines: {\r\n\t\tPERSPECTIVE_CAMERA: 1\r\n\t},\r\n\r\n\tuniforms: {\r\n\t\ttDepth: { value: null },\r\n\t\tcameraNear: { value: null },\r\n\t\tcameraFar: { value: null },\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\t\tuniform sampler2D tDepth;\r\n\t\tuniform float cameraNear;\r\n\t\tuniform float cameraFar;\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\t#include <packing>\r\n\r\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\r\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\r\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\r\n\t\t\t#else\r\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\t\t\tfloat depth = getLinearDepth( vUv );\r\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\n/**\r\n * GTAO blend shader. Use by {@link GTAOPass}.\r\n *\r\n * @constant\r\n * @type {Object}\r\n */\r\nconst GTAOBlendShader = {\r\n\r\n\tname: 'GTAOBlendShader',\r\n\r\n\tuniforms: {\r\n\t\ttDiffuse: { value: null },\r\n\t\tintensity: { value: 1.0 }\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\t\tuniform float intensity;\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\r\n\t\t\tgl_FragColor = vec4(mix(vec3(1.), texel.rgb, intensity), texel.a);\r\n\t\t}`\r\n\r\n};\r\n\r\n\r\nfunction generateMagicSquareNoise( size = 5 ) {\r\n\r\n\tconst noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );\r\n\tconst magicSquare = generateMagicSquare( noiseSize );\r\n\tconst noiseSquareSize = magicSquare.length;\r\n\tconst data = new Uint8Array( noiseSquareSize * 4 );\r\n\r\n\tfor ( let inx = 0; inx < noiseSquareSize; ++ inx ) {\r\n\r\n\t\tconst iAng = magicSquare[ inx ];\r\n\t\tconst angle = ( 2 * Math.PI * iAng ) / noiseSquareSize;\r\n\t\tconst randomVec = new Vector3(\r\n\t\t\tMath.cos( angle ),\r\n\t\t\tMath.sin( angle ),\r\n\t\t\t0\r\n\t\t).normalize();\r\n\t\tdata[ inx * 4 ] = ( randomVec.x * 0.5 + 0.5 ) * 255;\r\n\t\tdata[ inx * 4 + 1 ] = ( randomVec.y * 0.5 + 0.5 ) * 255;\r\n\t\tdata[ inx * 4 + 2 ] = 127;\r\n\t\tdata[ inx * 4 + 3 ] = 255;\r\n\r\n\t}\r\n\r\n\tconst noiseTexture = new DataTexture( data, noiseSize, noiseSize );\r\n\tnoiseTexture.wrapS = RepeatWrapping;\r\n\tnoiseTexture.wrapT = RepeatWrapping;\r\n\tnoiseTexture.needsUpdate = true;\r\n\r\n\treturn noiseTexture;\r\n\r\n}\r\n\r\nfunction generateMagicSquare( size ) {\r\n\r\n\tconst noiseSize = Math.floor( size ) % 2 === 0 ? Math.floor( size ) + 1 : Math.floor( size );\r\n\tconst noiseSquareSize = noiseSize * noiseSize;\r\n\tconst magicSquare = Array( noiseSquareSize ).fill( 0 );\r\n\tlet i = Math.floor( noiseSize / 2 );\r\n\tlet j = noiseSize - 1;\r\n\r\n\tfor ( let num = 1; num <= noiseSquareSize; ) {\r\n\r\n\t\tif ( i === - 1 && j === noiseSize ) {\r\n\r\n\t\t\tj = noiseSize - 2;\r\n\t\t\ti = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( j === noiseSize ) {\r\n\r\n\t\t\t\tj = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( i < 0 ) {\r\n\r\n\t\t\t\ti = noiseSize - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( magicSquare[ i * noiseSize + j ] !== 0 ) {\r\n\r\n\t\t\tj -= 2;\r\n\t\t\ti ++;\r\n\t\t\tcontinue;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmagicSquare[ i * noiseSize + j ] = num ++;\r\n\r\n\t\t}\r\n\r\n\t\tj ++;\r\n\t\ti --;\r\n\r\n\t}\r\n\r\n\treturn magicSquare;\r\n\r\n}\r\n\r\n\r\nexport { generateMagicSquareNoise, GTAOShader, GTAODepthShader, GTAOBlendShader };\r\n", "import {\r\n\tMatrix4,\r\n\tVector2,\r\n\tVector3,\r\n} from 'three';\r\n\r\n/**\r\n * @module PoissonDenoiseShader\r\n * @three_import import { PoissonDenoiseShader } from 'three/addons/shaders/PoissonDenoiseShader.js';\r\n */\r\n\r\n/**\r\n * Poisson Denoise Shader.\r\n *\r\n * References:\r\n * - [Self-Supervised Poisson-Gaussian Denoising](https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf).\r\n * - [Poisson2Sparse: Self-Supervised Poisson Denoising From a Single Image](https://arxiv.org/pdf/2206.01856.pdf)\r\n *\r\n * @constant\r\n * @type {ShaderMaterial~Shader}\r\n */\r\nconst PoissonDenoiseShader = {\r\n\r\n\tname: 'PoissonDenoiseShader',\r\n\r\n\tdefines: {\r\n\t\t'SAMPLES': 16,\r\n\t\t'SAMPLE_VECTORS': generatePdSamplePointInitializer( 16, 2, 1 ),\r\n\t\t'NORMAL_VECTOR_TYPE': 1,\r\n\t\t'DEPTH_VALUE_SOURCE': 0,\r\n\t},\r\n\r\n\tuniforms: {\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'tNormal': { value: null },\r\n\t\t'tDepth': { value: null },\r\n\t\t'tNoise': { value: null },\r\n\t\t'resolution': { value: new Vector2() },\r\n\t\t'cameraProjectionMatrixInverse': { value: new Matrix4() },\r\n\t\t'lumaPhi': { value: 5. },\r\n\t\t'depthPhi': { value: 5. },\r\n\t\t'normalPhi': { value: 5. },\r\n\t\t'radius': { value: 4. },\r\n\t\t'index': { value: 0 }\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform sampler2D tNormal;\r\n\t\tuniform sampler2D tDepth;\r\n\t\tuniform sampler2D tNoise;\r\n\t\tuniform vec2 resolution;\r\n\t\tuniform mat4 cameraProjectionMatrixInverse;\r\n\t\tuniform float lumaPhi;\r\n\t\tuniform float depthPhi;\r\n\t\tuniform float normalPhi;\r\n\t\tuniform float radius;\r\n\t\tuniform int index;\r\n\r\n\t\t#include <common>\r\n\t\t#include <packing>\r\n\r\n\t\t#ifndef SAMPLE_LUMINANCE\r\n\t\t#define SAMPLE_LUMINANCE dot(vec3(0.2125, 0.7154, 0.0721), a)\r\n\t\t#endif\r\n\r\n\t\t#ifndef FRAGMENT_OUTPUT\r\n\t\t#define FRAGMENT_OUTPUT vec4(denoised, 1.)\r\n\t\t#endif\r\n\r\n\t\tfloat getLuminance(const in vec3 a) {\r\n\t\t\treturn SAMPLE_LUMINANCE;\r\n\t\t}\r\n\r\n\t\tconst vec3 poissonDisk[SAMPLES] = SAMPLE_VECTORS;\r\n\r\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth) {\r\n\t\t\tvec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);\r\n\t\t\tvec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;\r\n\t\t\treturn viewSpacePosition.xyz / viewSpacePosition.w;\r\n\t\t}\r\n\r\n\t\tfloat getDepth(const vec2 uv) {\r\n\t\t#if DEPTH_VALUE_SOURCE == 1\r\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).a;\r\n\t\t#else\r\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).r;\r\n\t\t#endif\r\n\t\t}\r\n\r\n\t\tfloat fetchDepth(const ivec2 uv) {\r\n\t\t\t#if DEPTH_VALUE_SOURCE == 1\r\n\t\t\t\treturn texelFetch(tDepth, uv.xy, 0).a;\r\n\t\t\t#else\r\n\t\t\t\treturn texelFetch(tDepth, uv.xy, 0).r;\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tvec3 computeNormalFromDepth(const vec2 uv) {\r\n\t\t\tvec2 size = vec2(textureSize(tDepth, 0));\r\n\t\t\tivec2 p = ivec2(uv * size);\r\n\t\t\tfloat c0 = fetchDepth(p);\r\n\t\t\tfloat l2 = fetchDepth(p - ivec2(2, 0));\r\n\t\t\tfloat l1 = fetchDepth(p - ivec2(1, 0));\r\n\t\t\tfloat r1 = fetchDepth(p + ivec2(1, 0));\r\n\t\t\tfloat r2 = fetchDepth(p + ivec2(2, 0));\r\n\t\t\tfloat b2 = fetchDepth(p - ivec2(0, 2));\r\n\t\t\tfloat b1 = fetchDepth(p - ivec2(0, 1));\r\n\t\t\tfloat t1 = fetchDepth(p + ivec2(0, 1));\r\n\t\t\tfloat t2 = fetchDepth(p + ivec2(0, 2));\r\n\t\t\tfloat dl = abs((2.0 * l1 - l2) - c0);\r\n\t\t\tfloat dr = abs((2.0 * r1 - r2) - c0);\r\n\t\t\tfloat db = abs((2.0 * b1 - b2) - c0);\r\n\t\t\tfloat dt = abs((2.0 * t1 - t2) - c0);\r\n\t\t\tvec3 ce = getViewPosition(uv, c0).xyz;\r\n\t\t\tvec3 dpdx = (dl < dr) ?  ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz\r\n\t\t\t\t\t\t\t\t\t: -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;\r\n\t\t\tvec3 dpdy = (db < dt) ?  ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz\r\n\t\t\t\t\t\t\t\t\t: -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;\r\n\t\t\treturn normalize(cross(dpdx, dpdy));\r\n\t\t}\r\n\r\n\t\tvec3 getViewNormal(const vec2 uv) {\r\n\t\t#if NORMAL_VECTOR_TYPE == 2\r\n\t\t\treturn normalize(textureLod(tNormal, uv, 0.).rgb);\r\n\t\t#elif NORMAL_VECTOR_TYPE == 1\r\n\t\t\treturn unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);\r\n\t\t#else\r\n\t\t\treturn computeNormalFromDepth(uv);\r\n\t\t#endif\r\n\t\t}\r\n\r\n\t\tvoid denoiseSample(in vec3 center, in vec3 viewNormal, in vec3 viewPos, in vec2 sampleUv, inout vec3 denoised, inout float totalWeight) {\r\n\t\t\tvec4 sampleTexel = textureLod(tDiffuse, sampleUv, 0.0);\r\n\t\t\tfloat sampleDepth = getDepth(sampleUv);\r\n\t\t\tvec3 sampleNormal = getViewNormal(sampleUv);\r\n\t\t\tvec3 neighborColor = sampleTexel.rgb;\r\n\t\t\tvec3 viewPosSample = getViewPosition(sampleUv, sampleDepth);\r\n\r\n\t\t\tfloat normalDiff = dot(viewNormal, sampleNormal);\r\n\t\t\tfloat normalSimilarity = pow(max(normalDiff, 0.), normalPhi);\r\n\t\t\tfloat lumaDiff = abs(getLuminance(neighborColor) - getLuminance(center));\r\n\t\t\tfloat lumaSimilarity = max(1.0 - lumaDiff / lumaPhi, 0.0);\r\n\t\t\tfloat depthDiff = abs(dot(viewPos - viewPosSample, viewNormal));\r\n\t\t\tfloat depthSimilarity = max(1. - depthDiff / depthPhi, 0.);\r\n\t\t\tfloat w = lumaSimilarity * depthSimilarity * normalSimilarity;\r\n\r\n\t\t\tdenoised += w * neighborColor;\r\n\t\t\ttotalWeight += w;\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\t\t\tfloat depth = getDepth(vUv.xy);\r\n\t\t\tvec3 viewNormal = getViewNormal(vUv);\r\n\t\t\tif (depth == 1. || dot(viewNormal, viewNormal) == 0.) {\r\n\t\t\t\tdiscard;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvec4 texel = textureLod(tDiffuse, vUv, 0.0);\r\n\t\t\tvec3 center = texel.rgb;\r\n\t\t\tvec3 viewPos = getViewPosition(vUv, depth);\r\n\r\n\t\t\tvec2 noiseResolution = vec2(textureSize(tNoise, 0));\r\n\t\t\tvec2 noiseUv = vUv * resolution / noiseResolution;\r\n\t\t\tvec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);\r\n      \t\tvec2 noiseVec = vec2(sin(noiseTexel[index % 4] * 2. * PI), cos(noiseTexel[index % 4] * 2. * PI));\r\n    \t\tmat2 rotationMatrix = mat2(noiseVec.x, -noiseVec.y, noiseVec.x, noiseVec.y);\r\n\r\n\t\t\tfloat totalWeight = 1.0;\r\n\t\t\tvec3 denoised = texel.rgb;\r\n\t\t\tfor (int i = 0; i < SAMPLES; i++) {\r\n\t\t\t\tvec3 sampleDir = poissonDisk[i];\r\n\t\t\t\tvec2 offset = rotationMatrix * (sampleDir.xy * (1. + sampleDir.z * (radius - 1.)) / resolution);\r\n\t\t\t\tvec2 sampleUv = vUv + offset;\r\n\t\t\t\tdenoiseSample(center, viewNormal, viewPos, sampleUv, denoised, totalWeight);\r\n\t\t\t}\r\n\r\n\t\t\tif (totalWeight > 0.) {\r\n\t\t\t\tdenoised /= totalWeight;\r\n\t\t\t}\r\n\t\t\tgl_FragColor = FRAGMENT_OUTPUT;\r\n\t\t}`\r\n\r\n};\r\n\r\nfunction generatePdSamplePointInitializer( samples, rings, radiusExponent ) {\r\n\r\n\tconst poissonDisk = generateDenoiseSamples(\r\n\t\tsamples,\r\n\t\trings,\r\n\t\tradiusExponent,\r\n\t);\r\n\r\n\tlet glslCode = 'vec3[SAMPLES](';\r\n\r\n\tfor ( let i = 0; i < samples; i ++ ) {\r\n\r\n\t\tconst sample = poissonDisk[ i ];\r\n\t\tglslCode += `vec3(${sample.x}, ${sample.y}, ${sample.z})${( i < samples - 1 ) ? ',' : ')'}`;\r\n\r\n\t}\r\n\r\n\treturn glslCode;\r\n\r\n}\r\n\r\nfunction generateDenoiseSamples( numSamples, numRings, radiusExponent ) {\r\n\r\n\tconst samples = [];\r\n\r\n\tfor ( let i = 0; i < numSamples; i ++ ) {\r\n\r\n\t\tconst angle = 2 * Math.PI * numRings * i / numSamples;\r\n\t\tconst radius = Math.pow( i / ( numSamples - 1 ), radiusExponent );\r\n\t\tsamples.push( new Vector3( Math.cos( angle ), Math.sin( angle ), radius ) );\r\n\r\n\t}\r\n\r\n\treturn samples;\r\n\r\n}\r\n\r\nexport { generatePdSamplePointInitializer, PoissonDenoiseShader };\r\n", "/**\r\n * A utility class providing noise functions.\r\n *\r\n * The code is based on [Simplex noise demystified](https://web.archive.org/web/20210210162332/http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf)\r\n * by Stefan Gustavson, 2005.\r\n *\r\n * @three_import import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';\r\n */\r\nclass SimplexNoise {\r\n\r\n\t/**\r\n\t * Constructs a new simplex noise object.\r\n\t *\r\n\t * @param {Object} [r=Math] - A math utility class that holds a `random()` method. This makes it\r\n\t * possible to pass in custom random number generator.\r\n\t */\r\n\tconstructor( r = Math ) {\r\n\r\n\t\tthis.grad3 = [[ 1, 1, 0 ], [ - 1, 1, 0 ], [ 1, - 1, 0 ], [ - 1, - 1, 0 ],\r\n\t\t\t[ 1, 0, 1 ], [ - 1, 0, 1 ], [ 1, 0, - 1 ], [ - 1, 0, - 1 ],\r\n\t\t\t[ 0, 1, 1 ], [ 0, - 1, 1 ], [ 0, 1, - 1 ], [ 0, - 1, - 1 ]];\r\n\r\n\t\tthis.grad4 = [[ 0, 1, 1, 1 ], [ 0, 1, 1, - 1 ], [ 0, 1, - 1, 1 ], [ 0, 1, - 1, - 1 ],\r\n\t\t\t[ 0, - 1, 1, 1 ], [ 0, - 1, 1, - 1 ], [ 0, - 1, - 1, 1 ], [ 0, - 1, - 1, - 1 ],\r\n\t\t\t[ 1, 0, 1, 1 ], [ 1, 0, 1, - 1 ], [ 1, 0, - 1, 1 ], [ 1, 0, - 1, - 1 ],\r\n\t\t\t[ - 1, 0, 1, 1 ], [ - 1, 0, 1, - 1 ], [ - 1, 0, - 1, 1 ], [ - 1, 0, - 1, - 1 ],\r\n\t\t\t[ 1, 1, 0, 1 ], [ 1, 1, 0, - 1 ], [ 1, - 1, 0, 1 ], [ 1, - 1, 0, - 1 ],\r\n\t\t\t[ - 1, 1, 0, 1 ], [ - 1, 1, 0, - 1 ], [ - 1, - 1, 0, 1 ], [ - 1, - 1, 0, - 1 ],\r\n\t\t\t[ 1, 1, 1, 0 ], [ 1, 1, - 1, 0 ], [ 1, - 1, 1, 0 ], [ 1, - 1, - 1, 0 ],\r\n\t\t\t[ - 1, 1, 1, 0 ], [ - 1, 1, - 1, 0 ], [ - 1, - 1, 1, 0 ], [ - 1, - 1, - 1, 0 ]];\r\n\r\n\t\tthis.p = [];\r\n\r\n\t\tfor ( let i = 0; i < 256; i ++ ) {\r\n\r\n\t\t\tthis.p[ i ] = Math.floor( r.random() * 256 );\r\n\r\n\t\t}\r\n\r\n\t\t// To remove the need for index wrapping, double the permutation table length\r\n\t\tthis.perm = [];\r\n\r\n\t\tfor ( let i = 0; i < 512; i ++ ) {\r\n\r\n\t\t\tthis.perm[ i ] = this.p[ i & 255 ];\r\n\r\n\t\t}\r\n\r\n\t\t// A lookup table to traverse the simplex around a given point in 4D.\r\n\t\t// Details can be found where this table is used, in the 4D noise method.\r\n\t\tthis.simplex = [\r\n\t\t\t[ 0, 1, 2, 3 ], [ 0, 1, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 2, 3, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 2, 3, 0 ],\r\n\t\t\t[ 0, 2, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 3, 1, 2 ], [ 0, 3, 2, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 3, 2, 0 ],\r\n\t\t\t[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],\r\n\t\t\t[ 1, 2, 0, 3 ], [ 0, 0, 0, 0 ], [ 1, 3, 0, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 3, 0, 1 ], [ 2, 3, 1, 0 ],\r\n\t\t\t[ 1, 0, 2, 3 ], [ 1, 0, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 0, 3, 1 ], [ 0, 0, 0, 0 ], [ 2, 1, 3, 0 ],\r\n\t\t\t[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],\r\n\t\t\t[ 2, 0, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 0, 1, 2 ], [ 3, 0, 2, 1 ], [ 0, 0, 0, 0 ], [ 3, 1, 2, 0 ],\r\n\t\t\t[ 2, 1, 0, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 1, 0, 2 ], [ 0, 0, 0, 0 ], [ 3, 2, 0, 1 ], [ 3, 2, 1, 0 ]];\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A 2D simplex noise method.\r\n\t *\r\n\t * @param {number} xin - The x coordinate.\r\n\t * @param {number} yin - The y coordinate.\r\n\t * @return {number} The noise value.\r\n\t */\r\n\tnoise( xin, yin ) {\r\n\r\n\t\tlet n0; // Noise contributions from the three corners\r\n\t\tlet n1;\r\n\t\tlet n2;\r\n\t\t// Skew the input space to determine which simplex cell we're in\r\n\t\tconst F2 = 0.5 * ( Math.sqrt( 3.0 ) - 1.0 );\r\n\t\tconst s = ( xin + yin ) * F2; // Hairy factor for 2D\r\n\t\tconst i = Math.floor( xin + s );\r\n\t\tconst j = Math.floor( yin + s );\r\n\t\tconst G2 = ( 3.0 - Math.sqrt( 3.0 ) ) / 6.0;\r\n\t\tconst t = ( i + j ) * G2;\r\n\t\tconst X0 = i - t; // Unskew the cell origin back to (x,y) space\r\n\t\tconst Y0 = j - t;\r\n\t\tconst x0 = xin - X0; // The x,y distances from the cell origin\r\n\t\tconst y0 = yin - Y0;\r\n\r\n\t\t// For the 2D case, the simplex shape is an equilateral triangle.\r\n\t\t// Determine which simplex we are in.\r\n\t\tlet i1; // Offsets for second (middle) corner of simplex in (i,j) coords\r\n\r\n\t\tlet j1;\r\n\t\tif ( x0 > y0 ) {\r\n\r\n\t\t\ti1 = 1; j1 = 0;\r\n\r\n\t\t\t// lower triangle, XY order: (0,0)->(1,0)->(1,1)\r\n\r\n\t\t}\telse {\r\n\r\n\t\t\ti1 = 0; j1 = 1;\r\n\r\n\t\t} // upper triangle, YX order: (0,0)->(0,1)->(1,1)\r\n\r\n\t\t// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\r\n\t\t// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\r\n\t\t// c = (3-sqrt(3))/6\r\n\t\tconst x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\r\n\t\tconst y1 = y0 - j1 + G2;\r\n\t\tconst x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\r\n\t\tconst y2 = y0 - 1.0 + 2.0 * G2;\r\n\t\t// Work out the hashed gradient indices of the three simplex corners\r\n\t\tconst ii = i & 255;\r\n\t\tconst jj = j & 255;\r\n\t\tconst gi0 = this.perm[ ii + this.perm[ jj ] ] % 12;\r\n\t\tconst gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 ] ] % 12;\r\n\t\tconst gi2 = this.perm[ ii + 1 + this.perm[ jj + 1 ] ] % 12;\r\n\t\t// Calculate the contribution from the three corners\r\n\t\tlet t0 = 0.5 - x0 * x0 - y0 * y0;\r\n\t\tif ( t0 < 0 ) n0 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt0 *= t0;\r\n\t\t\tn0 = t0 * t0 * this._dot( this.grad3[ gi0 ], x0, y0 ); // (x,y) of grad3 used for 2D gradient\r\n\r\n\t\t}\r\n\r\n\t\tlet t1 = 0.5 - x1 * x1 - y1 * y1;\r\n\t\tif ( t1 < 0 ) n1 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt1 *= t1;\r\n\t\t\tn1 = t1 * t1 * this._dot( this.grad3[ gi1 ], x1, y1 );\r\n\r\n\t\t}\r\n\r\n\t\tlet t2 = 0.5 - x2 * x2 - y2 * y2;\r\n\t\tif ( t2 < 0 ) n2 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt2 *= t2;\r\n\t\t\tn2 = t2 * t2 * this._dot( this.grad3[ gi2 ], x2, y2 );\r\n\r\n\t\t}\r\n\r\n\t\t// Add contributions from each corner to get the final noise value.\r\n\t\t// The result is scaled to return values in the interval [-1,1].\r\n\t\treturn 70.0 * ( n0 + n1 + n2 );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A 3D simplex noise method.\r\n\t *\r\n\t * @param {number} xin - The x coordinate.\r\n\t * @param {number} yin - The y coordinate.\r\n\t * @param {number} zin - The z coordinate.\r\n\t * @return {number} The noise value.\r\n\t */\r\n\tnoise3d( xin, yin, zin ) {\r\n\r\n\t\tlet n0; // Noise contributions from the four corners\r\n\t\tlet n1;\r\n\t\tlet n2;\r\n\t\tlet n3;\r\n\t\t// Skew the input space to determine which simplex cell we're in\r\n\t\tconst F3 = 1.0 / 3.0;\r\n\t\tconst s = ( xin + yin + zin ) * F3; // Very nice and simple skew factor for 3D\r\n\t\tconst i = Math.floor( xin + s );\r\n\t\tconst j = Math.floor( yin + s );\r\n\t\tconst k = Math.floor( zin + s );\r\n\t\tconst G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\r\n\t\tconst t = ( i + j + k ) * G3;\r\n\t\tconst X0 = i - t; // Unskew the cell origin back to (x,y,z) space\r\n\t\tconst Y0 = j - t;\r\n\t\tconst Z0 = k - t;\r\n\t\tconst x0 = xin - X0; // The x,y,z distances from the cell origin\r\n\t\tconst y0 = yin - Y0;\r\n\t\tconst z0 = zin - Z0;\r\n\r\n\t\t// For the 3D case, the simplex shape is a slightly irregular tetrahedron.\r\n\t\t// Determine which simplex we are in.\r\n\t\tlet i1; // Offsets for second corner of simplex in (i,j,k) coords\r\n\r\n\t\tlet j1;\r\n\t\tlet k1;\r\n\t\tlet i2; // Offsets for third corner of simplex in (i,j,k) coords\r\n\t\tlet j2;\r\n\t\tlet k2;\r\n\t\tif ( x0 >= y0 ) {\r\n\r\n\t\t\tif ( y0 >= z0 ) {\r\n\r\n\t\t\t\ti1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\r\n\r\n\t\t\t\t// X Y Z order\r\n\r\n\t\t\t} else if ( x0 >= z0 ) {\r\n\r\n\t\t\t\ti1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;\r\n\r\n\t\t\t\t// X Z Y order\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ti1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;\r\n\r\n\t\t\t} // Z X Y order\r\n\r\n\t\t} else { // x0<y0\r\n\r\n\t\t\tif ( y0 < z0 ) {\r\n\r\n\t\t\t\ti1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;\r\n\r\n\t\t\t\t// Z Y X order\r\n\r\n\t\t\t} else if ( x0 < z0 ) {\r\n\r\n\t\t\t\ti1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;\r\n\r\n\t\t\t\t// Y Z X order\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ti1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;\r\n\r\n\t\t\t} // Y X Z order\r\n\r\n\t\t}\r\n\r\n\t\t// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\r\n\t\t// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\r\n\t\t// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\r\n\t\t// c = 1/6.\r\n\t\tconst x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\r\n\t\tconst y1 = y0 - j1 + G3;\r\n\t\tconst z1 = z0 - k1 + G3;\r\n\t\tconst x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\r\n\t\tconst y2 = y0 - j2 + 2.0 * G3;\r\n\t\tconst z2 = z0 - k2 + 2.0 * G3;\r\n\t\tconst x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\r\n\t\tconst y3 = y0 - 1.0 + 3.0 * G3;\r\n\t\tconst z3 = z0 - 1.0 + 3.0 * G3;\r\n\t\t// Work out the hashed gradient indices of the four simplex corners\r\n\t\tconst ii = i & 255;\r\n\t\tconst jj = j & 255;\r\n\t\tconst kk = k & 255;\r\n\t\tconst gi0 = this.perm[ ii + this.perm[ jj + this.perm[ kk ] ] ] % 12;\r\n\t\tconst gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 + this.perm[ kk + k1 ] ] ] % 12;\r\n\t\tconst gi2 = this.perm[ ii + i2 + this.perm[ jj + j2 + this.perm[ kk + k2 ] ] ] % 12;\r\n\t\tconst gi3 = this.perm[ ii + 1 + this.perm[ jj + 1 + this.perm[ kk + 1 ] ] ] % 12;\r\n\t\t// Calculate the contribution from the four corners\r\n\t\tlet t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\r\n\t\tif ( t0 < 0 ) n0 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt0 *= t0;\r\n\t\t\tn0 = t0 * t0 * this._dot3( this.grad3[ gi0 ], x0, y0, z0 );\r\n\r\n\t\t}\r\n\r\n\t\tlet t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\r\n\t\tif ( t1 < 0 ) n1 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt1 *= t1;\r\n\t\t\tn1 = t1 * t1 * this._dot3( this.grad3[ gi1 ], x1, y1, z1 );\r\n\r\n\t\t}\r\n\r\n\t\tlet t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\r\n\t\tif ( t2 < 0 ) n2 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt2 *= t2;\r\n\t\t\tn2 = t2 * t2 * this._dot3( this.grad3[ gi2 ], x2, y2, z2 );\r\n\r\n\t\t}\r\n\r\n\t\tlet t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\r\n\t\tif ( t3 < 0 ) n3 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt3 *= t3;\r\n\t\t\tn3 = t3 * t3 * this._dot3( this.grad3[ gi3 ], x3, y3, z3 );\r\n\r\n\t\t}\r\n\r\n\t\t// Add contributions from each corner to get the final noise value.\r\n\t\t// The result is scaled to stay just inside [-1,1]\r\n\t\treturn 32.0 * ( n0 + n1 + n2 + n3 );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A 4D simplex noise method.\r\n\t *\r\n\t * @param {number} x - The x coordinate.\r\n\t * @param {number} y - The y coordinate.\r\n\t * @param {number} z - The z coordinate.\r\n\t * @param {number} w - The w coordinate.\r\n\t * @return {number} The noise value.\r\n\t */\r\n\tnoise4d( x, y, z, w ) {\r\n\r\n\t\t// For faster and easier lookups\r\n\t\tconst grad4 = this.grad4;\r\n\t\tconst simplex = this.simplex;\r\n\t\tconst perm = this.perm;\r\n\r\n\t\t// The skewing and unskewing factors are hairy again for the 4D case\r\n\t\tconst F4 = ( Math.sqrt( 5.0 ) - 1.0 ) / 4.0;\r\n\t\tconst G4 = ( 5.0 - Math.sqrt( 5.0 ) ) / 20.0;\r\n\t\tlet n0; // Noise contributions from the five corners\r\n\t\tlet n1;\r\n\t\tlet n2;\r\n\t\tlet n3;\r\n\t\tlet n4;\r\n\t\t// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\r\n\t\tconst s = ( x + y + z + w ) * F4; // Factor for 4D skewing\r\n\t\tconst i = Math.floor( x + s );\r\n\t\tconst j = Math.floor( y + s );\r\n\t\tconst k = Math.floor( z + s );\r\n\t\tconst l = Math.floor( w + s );\r\n\t\tconst t = ( i + j + k + l ) * G4; // Factor for 4D unskewing\r\n\t\tconst X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\r\n\t\tconst Y0 = j - t;\r\n\t\tconst Z0 = k - t;\r\n\t\tconst W0 = l - t;\r\n\t\tconst x0 = x - X0; // The x,y,z,w distances from the cell origin\r\n\t\tconst y0 = y - Y0;\r\n\t\tconst z0 = z - Z0;\r\n\t\tconst w0 = w - W0;\r\n\r\n\t\t// For the 4D case, the simplex is a 4D shape I won't even try to describe.\r\n\t\t// To find out which of the 24 possible simplices we're in, we need to\r\n\t\t// determine the magnitude ordering of x0, y0, z0 and w0.\r\n\t\t// The method below is a good way of finding the ordering of x,y,z,w and\r\n\t\t// then find the correct traversal order for the simplex weâ€™re in.\r\n\t\t// First, six pair-wise comparisons are performed between each possible pair\r\n\t\t// of the four coordinates, and the results are used to add up binary bits\r\n\t\t// for an integer index.\r\n\t\tconst c1 = ( x0 > y0 ) ? 32 : 0;\r\n\t\tconst c2 = ( x0 > z0 ) ? 16 : 0;\r\n\t\tconst c3 = ( y0 > z0 ) ? 8 : 0;\r\n\t\tconst c4 = ( x0 > w0 ) ? 4 : 0;\r\n\t\tconst c5 = ( y0 > w0 ) ? 2 : 0;\r\n\t\tconst c6 = ( z0 > w0 ) ? 1 : 0;\r\n\t\tconst c = c1 + c2 + c3 + c4 + c5 + c6;\r\n\r\n\t\t// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\r\n\t\t// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\r\n\t\t// impossible. Only the 24 indices which have non-zero entries make any sense.\r\n\t\t// We use a thresholding to set the coordinates in turn from the largest magnitude.\r\n\t\t// The number 3 in the \"simplex\" array is at the position of the largest coordinate.\r\n\t\tconst i1 = simplex[ c ][ 0 ] >= 3 ? 1 : 0;\r\n\t\tconst j1 = simplex[ c ][ 1 ] >= 3 ? 1 : 0;\r\n\t\tconst k1 = simplex[ c ][ 2 ] >= 3 ? 1 : 0;\r\n\t\tconst l1 = simplex[ c ][ 3 ] >= 3 ? 1 : 0;\r\n\t\t// The number 2 in the \"simplex\" array is at the second largest coordinate.\r\n\t\tconst i2 = simplex[ c ][ 0 ] >= 2 ? 1 : 0;\r\n\t\tconst j2 = simplex[ c ][ 1 ] >= 2 ? 1 : 0;\r\n\t\tconst k2 = simplex[ c ][ 2 ] >= 2 ? 1 : 0;\r\n\t\tconst l2 = simplex[ c ][ 3 ] >= 2 ? 1 : 0;\r\n\t\t// The number 1 in the \"simplex\" array is at the second smallest coordinate.\r\n\t\tconst i3 = simplex[ c ][ 0 ] >= 1 ? 1 : 0;\r\n\t\tconst j3 = simplex[ c ][ 1 ] >= 1 ? 1 : 0;\r\n\t\tconst k3 = simplex[ c ][ 2 ] >= 1 ? 1 : 0;\r\n\t\tconst l3 = simplex[ c ][ 3 ] >= 1 ? 1 : 0;\r\n\t\t// The fifth corner has all coordinate offsets = 1, so no need to look that up.\r\n\t\tconst x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\r\n\t\tconst y1 = y0 - j1 + G4;\r\n\t\tconst z1 = z0 - k1 + G4;\r\n\t\tconst w1 = w0 - l1 + G4;\r\n\t\tconst x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\r\n\t\tconst y2 = y0 - j2 + 2.0 * G4;\r\n\t\tconst z2 = z0 - k2 + 2.0 * G4;\r\n\t\tconst w2 = w0 - l2 + 2.0 * G4;\r\n\t\tconst x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\r\n\t\tconst y3 = y0 - j3 + 3.0 * G4;\r\n\t\tconst z3 = z0 - k3 + 3.0 * G4;\r\n\t\tconst w3 = w0 - l3 + 3.0 * G4;\r\n\t\tconst x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\r\n\t\tconst y4 = y0 - 1.0 + 4.0 * G4;\r\n\t\tconst z4 = z0 - 1.0 + 4.0 * G4;\r\n\t\tconst w4 = w0 - 1.0 + 4.0 * G4;\r\n\t\t// Work out the hashed gradient indices of the five simplex corners\r\n\t\tconst ii = i & 255;\r\n\t\tconst jj = j & 255;\r\n\t\tconst kk = k & 255;\r\n\t\tconst ll = l & 255;\r\n\t\tconst gi0 = perm[ ii + perm[ jj + perm[ kk + perm[ ll ] ] ] ] % 32;\r\n\t\tconst gi1 = perm[ ii + i1 + perm[ jj + j1 + perm[ kk + k1 + perm[ ll + l1 ] ] ] ] % 32;\r\n\t\tconst gi2 = perm[ ii + i2 + perm[ jj + j2 + perm[ kk + k2 + perm[ ll + l2 ] ] ] ] % 32;\r\n\t\tconst gi3 = perm[ ii + i3 + perm[ jj + j3 + perm[ kk + k3 + perm[ ll + l3 ] ] ] ] % 32;\r\n\t\tconst gi4 = perm[ ii + 1 + perm[ jj + 1 + perm[ kk + 1 + perm[ ll + 1 ] ] ] ] % 32;\r\n\t\t// Calculate the contribution from the five corners\r\n\t\tlet t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\r\n\t\tif ( t0 < 0 ) n0 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt0 *= t0;\r\n\t\t\tn0 = t0 * t0 * this._dot4( grad4[ gi0 ], x0, y0, z0, w0 );\r\n\r\n\t\t}\r\n\r\n\t\tlet t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\r\n\t\tif ( t1 < 0 ) n1 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt1 *= t1;\r\n\t\t\tn1 = t1 * t1 * this._dot4( grad4[ gi1 ], x1, y1, z1, w1 );\r\n\r\n\t\t}\r\n\r\n\t\tlet t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\r\n\t\tif ( t2 < 0 ) n2 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt2 *= t2;\r\n\t\t\tn2 = t2 * t2 * this._dot4( grad4[ gi2 ], x2, y2, z2, w2 );\r\n\r\n\t\t}\r\n\r\n\t\tlet t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\r\n\t\tif ( t3 < 0 ) n3 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt3 *= t3;\r\n\t\t\tn3 = t3 * t3 * this._dot4( grad4[ gi3 ], x3, y3, z3, w3 );\r\n\r\n\t\t}\r\n\r\n\t\tlet t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\r\n\t\tif ( t4 < 0 ) n4 = 0.0;\r\n\t\telse {\r\n\r\n\t\t\tt4 *= t4;\r\n\t\t\tn4 = t4 * t4 * this._dot4( grad4[ gi4 ], x4, y4, z4, w4 );\r\n\r\n\t\t}\r\n\r\n\t\t// Sum up and scale the result to cover the range [-1,1]\r\n\t\treturn 27.0 * ( n0 + n1 + n2 + n3 + n4 );\r\n\r\n\t}\r\n\r\n\t// private\r\n\r\n\t_dot( g, x, y ) {\r\n\r\n\t\treturn g[ 0 ] * x + g[ 1 ] * y;\r\n\r\n\t}\r\n\r\n\t_dot3( g, x, y, z ) {\r\n\r\n\t\treturn g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z;\r\n\r\n\t}\r\n\r\n\t_dot4( g, x, y, z, w ) {\r\n\r\n\t\treturn g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z + g[ 3 ] * w;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { SimplexNoise };\r\n", "import {\r\n\tAddEquation,\r\n\tColor,\r\n\tCustomBlending,\r\n\tDataTexture,\r\n\tDepthTexture,\r\n\tDepthStencilFormat,\r\n\tDstAlphaFactor,\r\n\tDstColorFactor,\r\n\tHalfFloatType,\r\n\tMeshNormalMaterial,\r\n\tNearestFilter,\r\n\tNoBlending,\r\n\tRepeatWrapping,\r\n\tRGBAFormat,\r\n\tShaderMaterial,\r\n\tUniformsUtils,\r\n\tUnsignedByteType,\r\n\tUnsignedInt248Type,\r\n\tWebGLRenderTarget,\r\n\tZeroFactor\r\n} from 'three';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\nimport { generateMagicSquareNoise, GTAOShader, GTAODepthShader, GTAOBlendShader } from '../shaders/GTAOShader.js';\r\nimport { generatePdSamplePointInitializer, PoissonDenoiseShader } from '../shaders/PoissonDenoiseShader.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\nimport { SimplexNoise } from '../math/SimplexNoise.js';\r\n\r\n/**\r\n * A pass for an GTAO effect.\r\n *\r\n * `GTAOPass` provides better quality than {@link SSAOPass} but is also more expensive.\r\n *\r\n * ```js\r\n * const gtaoPass = new GTAOPass( scene, camera, width, height );\r\n * gtaoPass.output = GTAOPass.OUTPUT.Denoise;\r\n * composer.addPass( gtaoPass );\r\n * ```\r\n *\r\n * @augments Pass\r\n * @three_import import { GTAOPass } from 'three/addons/postprocessing/GTAOPass.js';\r\n */\r\nclass GTAOPass extends Pass {\r\n\r\n\t/**\r\n\t * Constructs a new GTAO pass.\r\n\t *\r\n\t * @param {Scene} scene - The scene to compute the AO for.\r\n\t * @param {Camera} camera - The camera.\r\n\t * @param {number} [width=512] - The width of the effect.\r\n\t * @param {number} [height=512] - The height of the effect.\r\n\t * @param {Object} [parameters] - The pass parameters.\r\n\t * @param {Object} [aoParameters] - The AO parameters.\r\n\t * @param {Object} [pdParameters] - The denoise parameters.\r\n\t */\r\n\tconstructor( scene, camera, width = 512, height = 512, parameters, aoParameters, pdParameters ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t\t * The width of the effect.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 512\r\n\t\t */\r\n\t\tthis.width = width;\r\n\r\n\t\t/**\r\n\t\t * The height of the effect.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 512\r\n\t\t */\r\n\t\tthis.height = height;\r\n\r\n\t\t/**\r\n\t\t * Overwritten to perform a clear operation by default.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.clear = true;\r\n\r\n\t\t/**\r\n\t\t * The camera.\r\n\t\t *\r\n\t\t * @type {Camera}\r\n\t\t */\r\n\t\tthis.camera = camera;\r\n\r\n\t\t/**\r\n\t\t * The scene to render the AO for.\r\n\t\t *\r\n\t\t * @type {Scene}\r\n\t\t */\r\n\t\tthis.scene = scene;\r\n\r\n\t\t/**\r\n\t\t * The output configuration.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 0\r\n\t\t */\r\n\t\tthis.output = 0;\r\n\t\tthis._renderGBuffer = true;\r\n\t\tthis._visibilityCache = [];\r\n\r\n\t\t/**\r\n\t\t * The AO blend intensity.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 1\r\n\t\t */\r\n\t\tthis.blendIntensity = 1.;\r\n\r\n\t\t/**\r\n\t\t * The number of Poisson Denoise rings.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 2\r\n\t\t */\r\n\t\tthis.pdRings = 2.;\r\n\r\n\t\t/**\r\n\t\t * The Poisson Denoise radius exponent.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 2\r\n\t\t */\r\n\t\tthis.pdRadiusExponent = 2.;\r\n\r\n\t\t/**\r\n\t\t * The Poisson Denoise sample count.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 16\r\n\t\t */\r\n\t\tthis.pdSamples = 16;\r\n\r\n\t\tthis.gtaoNoiseTexture = generateMagicSquareNoise();\r\n\t\tthis.pdNoiseTexture = this._generateNoise();\r\n\r\n\t\tthis.gtaoRenderTarget = new WebGLRenderTarget( this.width, this.height, { type: HalfFloatType } );\r\n\t\tthis.pdRenderTarget = this.gtaoRenderTarget.clone();\r\n\r\n\t\tthis.gtaoMaterial = new ShaderMaterial( {\r\n\t\t\tdefines: Object.assign( {}, GTAOShader.defines ),\r\n\t\t\tuniforms: UniformsUtils.clone( GTAOShader.uniforms ),\r\n\t\t\tvertexShader: GTAOShader.vertexShader,\r\n\t\t\tfragmentShader: GTAOShader.fragmentShader,\r\n\t\t\tblending: NoBlending,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\t\tthis.gtaoMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0;\r\n\t\tthis.gtaoMaterial.uniforms.tNoise.value = this.gtaoNoiseTexture;\r\n\t\tthis.gtaoMaterial.uniforms.resolution.value.set( this.width, this.height );\r\n\t\tthis.gtaoMaterial.uniforms.cameraNear.value = this.camera.near;\r\n\t\tthis.gtaoMaterial.uniforms.cameraFar.value = this.camera.far;\r\n\r\n\t\tthis.normalMaterial = new MeshNormalMaterial();\r\n\t\tthis.normalMaterial.blending = NoBlending;\r\n\r\n\t\tthis.pdMaterial = new ShaderMaterial( {\r\n\t\t\tdefines: Object.assign( {}, PoissonDenoiseShader.defines ),\r\n\t\t\tuniforms: UniformsUtils.clone( PoissonDenoiseShader.uniforms ),\r\n\t\t\tvertexShader: PoissonDenoiseShader.vertexShader,\r\n\t\t\tfragmentShader: PoissonDenoiseShader.fragmentShader,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\t\tthis.pdMaterial.uniforms.tDiffuse.value = this.gtaoRenderTarget.texture;\r\n\t\tthis.pdMaterial.uniforms.tNoise.value = this.pdNoiseTexture;\r\n\t\tthis.pdMaterial.uniforms.resolution.value.set( this.width, this.height );\r\n\t\tthis.pdMaterial.uniforms.lumaPhi.value = 10;\r\n\t\tthis.pdMaterial.uniforms.depthPhi.value = 2;\r\n\t\tthis.pdMaterial.uniforms.normalPhi.value = 3;\r\n\t\tthis.pdMaterial.uniforms.radius.value = 8;\r\n\r\n\t\tthis.depthRenderMaterial = new ShaderMaterial( {\r\n\t\t\tdefines: Object.assign( {}, GTAODepthShader.defines ),\r\n\t\t\tuniforms: UniformsUtils.clone( GTAODepthShader.uniforms ),\r\n\t\t\tvertexShader: GTAODepthShader.vertexShader,\r\n\t\t\tfragmentShader: GTAODepthShader.fragmentShader,\r\n\t\t\tblending: NoBlending\r\n\t\t} );\r\n\t\tthis.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near;\r\n\t\tthis.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far;\r\n\r\n\t\tthis.copyMaterial = new ShaderMaterial( {\r\n\t\t\tuniforms: UniformsUtils.clone( CopyShader.uniforms ),\r\n\t\t\tvertexShader: CopyShader.vertexShader,\r\n\t\t\tfragmentShader: CopyShader.fragmentShader,\r\n\t\t\ttransparent: true,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\tblendSrc: DstColorFactor,\r\n\t\t\tblendDst: ZeroFactor,\r\n\t\t\tblendEquation: AddEquation,\r\n\t\t\tblendSrcAlpha: DstAlphaFactor,\r\n\t\t\tblendDstAlpha: ZeroFactor,\r\n\t\t\tblendEquationAlpha: AddEquation\r\n\t\t} );\r\n\r\n\t\tthis.blendMaterial = new ShaderMaterial( {\r\n\t\t\tuniforms: UniformsUtils.clone( GTAOBlendShader.uniforms ),\r\n\t\t\tvertexShader: GTAOBlendShader.vertexShader,\r\n\t\t\tfragmentShader: GTAOBlendShader.fragmentShader,\r\n\t\t\ttransparent: true,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\tblending: CustomBlending,\r\n\t\t\tblendSrc: DstColorFactor,\r\n\t\t\tblendDst: ZeroFactor,\r\n\t\t\tblendEquation: AddEquation,\r\n\t\t\tblendSrcAlpha: DstAlphaFactor,\r\n\t\t\tblendDstAlpha: ZeroFactor,\r\n\t\t\tblendEquationAlpha: AddEquation\r\n\t\t} );\r\n\r\n\t\tthis._fsQuad = new FullScreenQuad( null );\r\n\r\n\t\tthis._originalClearColor = new Color();\r\n\r\n\t\tthis.setGBuffer( parameters ? parameters.depthTexture : undefined, parameters ? parameters.normalTexture : undefined );\r\n\r\n\t\tif ( aoParameters !== undefined ) {\r\n\r\n\t\t\tthis.updateGtaoMaterial( aoParameters );\r\n\r\n\t\t}\r\n\r\n\t\tif ( pdParameters !== undefined ) {\r\n\r\n\t\t\tthis.updatePdMaterial( pdParameters );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the size of the pass.\r\n\t *\r\n\t * @param {number} width - The width to set.\r\n\t * @param {number} height - The height to set.\r\n\t */\r\n\tsetSize( width, height ) {\r\n\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\r\n\t\tthis.gtaoRenderTarget.setSize( width, height );\r\n\t\tthis.normalRenderTarget.setSize( width, height );\r\n\t\tthis.pdRenderTarget.setSize( width, height );\r\n\r\n\t\tthis.gtaoMaterial.uniforms.resolution.value.set( width, height );\r\n\t\tthis.gtaoMaterial.uniforms.cameraProjectionMatrix.value.copy( this.camera.projectionMatrix );\r\n\t\tthis.gtaoMaterial.uniforms.cameraProjectionMatrixInverse.value.copy( this.camera.projectionMatrixInverse );\r\n\r\n\t\tthis.pdMaterial.uniforms.resolution.value.set( width, height );\r\n\t\tthis.pdMaterial.uniforms.cameraProjectionMatrixInverse.value.copy( this.camera.projectionMatrixInverse );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Frees the GPU-related resources allocated by this instance. Call this\r\n\t * method whenever the pass is no longer used in your app.\r\n\t */\r\n\tdispose() {\r\n\r\n\t\tthis.gtaoNoiseTexture.dispose();\r\n\t\tthis.pdNoiseTexture.dispose();\r\n\t\tthis.normalRenderTarget.dispose();\r\n\t\tthis.gtaoRenderTarget.dispose();\r\n\t\tthis.pdRenderTarget.dispose();\r\n\t\tthis.normalMaterial.dispose();\r\n\t\tthis.pdMaterial.dispose();\r\n\t\tthis.copyMaterial.dispose();\r\n\t\tthis.depthRenderMaterial.dispose();\r\n\t\tthis._fsQuad.dispose();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A texture holding the computed AO.\r\n\t *\r\n\t * @type {Texture}\r\n\t * @readonly\r\n\t */\r\n\tget gtaoMap() {\r\n\r\n\t\treturn this.pdRenderTarget.texture;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Configures the GBuffer of this pass. If no arguments are passed,\r\n\t * the pass creates an internal render target for holding depth\r\n\t * and normal data.\r\n\t *\r\n\t * @param {DepthTexture} [depthTexture] - The depth texture.\r\n\t * @param {DepthTexture} [normalTexture] - The normal texture.\r\n\t */\r\n\tsetGBuffer( depthTexture, normalTexture ) {\r\n\r\n\t\tif ( depthTexture !== undefined ) {\r\n\r\n\t\t\tthis.depthTexture = depthTexture;\r\n\t\t\tthis.normalTexture = normalTexture;\r\n\t\t\tthis._renderGBuffer = false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.depthTexture = new DepthTexture();\r\n\t\t\tthis.depthTexture.format = DepthStencilFormat;\r\n\t\t\tthis.depthTexture.type = UnsignedInt248Type;\r\n\t\t\tthis.normalRenderTarget = new WebGLRenderTarget( this.width, this.height, {\r\n\t\t\t\tminFilter: NearestFilter,\r\n\t\t\t\tmagFilter: NearestFilter,\r\n\t\t\t\ttype: HalfFloatType,\r\n\t\t\t\tdepthTexture: this.depthTexture\r\n\t\t\t} );\r\n\t\t\tthis.normalTexture = this.normalRenderTarget.texture;\r\n\t\t\tthis._renderGBuffer = true;\r\n\r\n\t\t}\r\n\r\n\t\tconst normalVectorType = ( this.normalTexture ) ? 1 : 0;\r\n\t\tconst depthValueSource = ( this.depthTexture === this.normalTexture ) ? 'w' : 'x';\r\n\r\n\t\tthis.gtaoMaterial.defines.NORMAL_VECTOR_TYPE = normalVectorType;\r\n\t\tthis.gtaoMaterial.defines.DEPTH_SWIZZLING = depthValueSource;\r\n\t\tthis.gtaoMaterial.uniforms.tNormal.value = this.normalTexture;\r\n\t\tthis.gtaoMaterial.uniforms.tDepth.value = this.depthTexture;\r\n\r\n\t\tthis.pdMaterial.defines.NORMAL_VECTOR_TYPE = normalVectorType;\r\n\t\tthis.pdMaterial.defines.DEPTH_SWIZZLING = depthValueSource;\r\n\t\tthis.pdMaterial.uniforms.tNormal.value = this.normalTexture;\r\n\t\tthis.pdMaterial.uniforms.tDepth.value = this.depthTexture;\r\n\r\n\t\tthis.depthRenderMaterial.uniforms.tDepth.value = this.normalRenderTarget.depthTexture;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Configures the clip box of the GTAO shader with the given AABB.\r\n\t *\r\n\t * @param {?Box3} box - The AABB enclosing the scene that should receive AO. When passing\r\n\t * `null`, to clip box is used.\r\n\t */\r\n\tsetSceneClipBox( box ) {\r\n\r\n\t\tif ( box ) {\r\n\r\n\t\t\tthis.gtaoMaterial.needsUpdate = this.gtaoMaterial.defines.SCENE_CLIP_BOX !== 1;\r\n\t\t\tthis.gtaoMaterial.defines.SCENE_CLIP_BOX = 1;\r\n\t\t\tthis.gtaoMaterial.uniforms.sceneBoxMin.value.copy( box.min );\r\n\t\t\tthis.gtaoMaterial.uniforms.sceneBoxMax.value.copy( box.max );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.gtaoMaterial.needsUpdate = this.gtaoMaterial.defines.SCENE_CLIP_BOX === 0;\r\n\t\t\tthis.gtaoMaterial.defines.SCENE_CLIP_BOX = 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the GTAO material from the given parameter object.\r\n\t *\r\n\t * @param {Object} parameters - The GTAO material parameters.\r\n\t */\r\n\tupdateGtaoMaterial( parameters ) {\r\n\r\n\t\tif ( parameters.radius !== undefined ) {\r\n\r\n\t\t\tthis.gtaoMaterial.uniforms.radius.value = parameters.radius;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.distanceExponent !== undefined ) {\r\n\r\n\t\t\tthis.gtaoMaterial.uniforms.distanceExponent.value = parameters.distanceExponent;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.thickness !== undefined ) {\r\n\r\n\t\t\tthis.gtaoMaterial.uniforms.thickness.value = parameters.thickness;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.distanceFallOff !== undefined ) {\r\n\r\n\t\t\tthis.gtaoMaterial.uniforms.distanceFallOff.value = parameters.distanceFallOff;\r\n\t\t\tthis.gtaoMaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.scale !== undefined ) {\r\n\r\n\t\t\tthis.gtaoMaterial.uniforms.scale.value = parameters.scale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.samples !== undefined && parameters.samples !== this.gtaoMaterial.defines.SAMPLES ) {\r\n\r\n\t\t\tthis.gtaoMaterial.defines.SAMPLES = parameters.samples;\r\n\t\t\tthis.gtaoMaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.screenSpaceRadius !== undefined && ( parameters.screenSpaceRadius ? 1 : 0 ) !== this.gtaoMaterial.defines.SCREEN_SPACE_RADIUS ) {\r\n\r\n\t\t\tthis.gtaoMaterial.defines.SCREEN_SPACE_RADIUS = parameters.screenSpaceRadius ? 1 : 0;\r\n\t\t\tthis.gtaoMaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the Denoise material from the given parameter object.\r\n\t *\r\n\t * @param {Object} parameters - The denoise parameters.\r\n\t */\r\n\tupdatePdMaterial( parameters ) {\r\n\r\n\t\tlet updateShader = false;\r\n\r\n\t\tif ( parameters.lumaPhi !== undefined ) {\r\n\r\n\t\t\tthis.pdMaterial.uniforms.lumaPhi.value = parameters.lumaPhi;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.depthPhi !== undefined ) {\r\n\r\n\t\t\tthis.pdMaterial.uniforms.depthPhi.value = parameters.depthPhi;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.normalPhi !== undefined ) {\r\n\r\n\t\t\tthis.pdMaterial.uniforms.normalPhi.value = parameters.normalPhi;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.radius !== undefined && parameters.radius !== this.radius ) {\r\n\r\n\t\t\tthis.pdMaterial.uniforms.radius.value = parameters.radius;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.radiusExponent !== undefined && parameters.radiusExponent !== this.pdRadiusExponent ) {\r\n\r\n\t\t\tthis.pdRadiusExponent = parameters.radiusExponent;\r\n\t\t\tupdateShader = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.rings !== undefined && parameters.rings !== this.pdRings ) {\r\n\r\n\t\t\tthis.pdRings = parameters.rings;\r\n\t\t\tupdateShader = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.samples !== undefined && parameters.samples !== this.pdSamples ) {\r\n\r\n\t\t\tthis.pdSamples = parameters.samples;\r\n\t\t\tupdateShader = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateShader ) {\r\n\r\n\t\t\tthis.pdMaterial.defines.SAMPLES = this.pdSamples;\r\n\t\t\tthis.pdMaterial.defines.SAMPLE_VECTORS = generatePdSamplePointInitializer( this.pdSamples, this.pdRings, this.pdRadiusExponent );\r\n\t\t\tthis.pdMaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs the GTAO pass.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\r\n\t * destination for the pass.\r\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\r\n\t * previous pass from this buffer.\r\n\t * @param {number} deltaTime - The delta time in seconds.\r\n\t * @param {boolean} maskActive - Whether masking is active or not.\r\n\t */\r\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\r\n\r\n\t\t// render normals and depth (honor only meshes, points and lines do not contribute to AO)\r\n\r\n\t\tif ( this._renderGBuffer ) {\r\n\r\n\t\t\tthis._overrideVisibility();\r\n\t\t\tthis._renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );\r\n\t\t\tthis._restoreVisibility();\r\n\r\n\t\t}\r\n\r\n\t\t// render AO\r\n\r\n\t\tthis.gtaoMaterial.uniforms.cameraNear.value = this.camera.near;\r\n\t\tthis.gtaoMaterial.uniforms.cameraFar.value = this.camera.far;\r\n\t\tthis.gtaoMaterial.uniforms.cameraProjectionMatrix.value.copy( this.camera.projectionMatrix );\r\n\t\tthis.gtaoMaterial.uniforms.cameraProjectionMatrixInverse.value.copy( this.camera.projectionMatrixInverse );\r\n\t\tthis.gtaoMaterial.uniforms.cameraWorldMatrix.value.copy( this.camera.matrixWorld );\r\n\t\tthis._renderPass( renderer, this.gtaoMaterial, this.gtaoRenderTarget, 0xffffff, 1.0 );\r\n\r\n\t\t// render poisson denoise\r\n\r\n\t\tthis.pdMaterial.uniforms.cameraProjectionMatrixInverse.value.copy( this.camera.projectionMatrixInverse );\r\n\t\tthis._renderPass( renderer, this.pdMaterial, this.pdRenderTarget, 0xffffff, 1.0 );\r\n\r\n\t\t// output result to screen\r\n\r\n\t\tswitch ( this.output ) {\r\n\r\n\t\t\tcase GTAOPass.OUTPUT.Off:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase GTAOPass.OUTPUT.Diffuse:\r\n\r\n\t\t\t\tthis.copyMaterial.uniforms.tDiffuse.value = readBuffer.texture;\r\n\t\t\t\tthis.copyMaterial.blending = NoBlending;\r\n\t\t\t\tthis._renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase GTAOPass.OUTPUT.AO:\r\n\r\n\t\t\t\tthis.copyMaterial.uniforms.tDiffuse.value = this.gtaoRenderTarget.texture;\r\n\t\t\t\tthis.copyMaterial.blending = NoBlending;\r\n\t\t\t\tthis._renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase GTAOPass.OUTPUT.Denoise:\r\n\r\n\t\t\t\tthis.copyMaterial.uniforms.tDiffuse.value = this.pdRenderTarget.texture;\r\n\t\t\t\tthis.copyMaterial.blending = NoBlending;\r\n\t\t\t\tthis._renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase GTAOPass.OUTPUT.Depth:\r\n\r\n\t\t\t\tthis.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near;\r\n\t\t\t\tthis.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far;\r\n\t\t\t\tthis._renderPass( renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase GTAOPass.OUTPUT.Normal:\r\n\r\n\t\t\t\tthis.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture;\r\n\t\t\t\tthis.copyMaterial.blending = NoBlending;\r\n\t\t\t\tthis._renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase GTAOPass.OUTPUT.Default:\r\n\r\n\t\t\t\tthis.copyMaterial.uniforms.tDiffuse.value = readBuffer.texture;\r\n\t\t\t\tthis.copyMaterial.blending = NoBlending;\r\n\t\t\t\tthis._renderPass( renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer );\r\n\r\n\t\t\t\tthis.blendMaterial.uniforms.intensity.value = this.blendIntensity;\r\n\t\t\t\tthis.blendMaterial.uniforms.tDiffuse.value = this.pdRenderTarget.texture;\r\n\t\t\t\tthis._renderPass( renderer, this.blendMaterial, this.renderToScreen ? null : writeBuffer );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.warn( 'THREE.GTAOPass: Unknown output type.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// internals\r\n\r\n\t_renderPass( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {\r\n\r\n\t\t// save original state\r\n\t\trenderer.getClearColor( this._originalClearColor );\r\n\t\tconst originalClearAlpha = renderer.getClearAlpha();\r\n\t\tconst originalAutoClear = renderer.autoClear;\r\n\r\n\t\trenderer.setRenderTarget( renderTarget );\r\n\r\n\t\t// setup pass state\r\n\t\trenderer.autoClear = false;\r\n\t\tif ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {\r\n\r\n\t\t\trenderer.setClearColor( clearColor );\r\n\t\t\trenderer.setClearAlpha( clearAlpha || 0.0 );\r\n\t\t\trenderer.clear();\r\n\r\n\t\t}\r\n\r\n\t\tthis._fsQuad.material = passMaterial;\r\n\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t// restore original state\r\n\t\trenderer.autoClear = originalAutoClear;\r\n\t\trenderer.setClearColor( this._originalClearColor );\r\n\t\trenderer.setClearAlpha( originalClearAlpha );\r\n\r\n\t}\r\n\r\n\t_renderOverride( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {\r\n\r\n\t\trenderer.getClearColor( this._originalClearColor );\r\n\t\tconst originalClearAlpha = renderer.getClearAlpha();\r\n\t\tconst originalAutoClear = renderer.autoClear;\r\n\r\n\t\trenderer.setRenderTarget( renderTarget );\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\tclearColor = overrideMaterial.clearColor || clearColor;\r\n\t\tclearAlpha = overrideMaterial.clearAlpha || clearAlpha;\r\n\r\n\t\tif ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {\r\n\r\n\t\t\trenderer.setClearColor( clearColor );\r\n\t\t\trenderer.setClearAlpha( clearAlpha || 0.0 );\r\n\t\t\trenderer.clear();\r\n\r\n\t\t}\r\n\r\n\t\tthis.scene.overrideMaterial = overrideMaterial;\r\n\t\trenderer.render( this.scene, this.camera );\r\n\t\tthis.scene.overrideMaterial = null;\r\n\r\n\t\trenderer.autoClear = originalAutoClear;\r\n\t\trenderer.setClearColor( this._originalClearColor );\r\n\t\trenderer.setClearAlpha( originalClearAlpha );\r\n\r\n\t}\r\n\r\n\t_overrideVisibility() {\r\n\r\n\t\tconst scene = this.scene;\r\n\t\tconst cache = this._visibilityCache;\r\n\r\n\t\tscene.traverse( function ( object ) {\r\n\r\n\t\t\tif ( ( object.isPoints || object.isLine || object.isLine2 ) && object.visible ) {\r\n\r\n\t\t\t\tobject.visible = false;\r\n\t\t\t\tcache.push( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_restoreVisibility() {\r\n\r\n\t\tconst cache = this._visibilityCache;\r\n\r\n\t\tfor ( let i = 0; i < cache.length; i ++ ) {\r\n\r\n\t\t\tcache[ i ].visible = true;\r\n\r\n\t\t}\r\n\r\n\t\tcache.length = 0;\r\n\r\n\t}\r\n\r\n\t_generateNoise( size = 64 ) {\r\n\r\n\t\tconst simplex = new SimplexNoise();\r\n\r\n\t\tconst arraySize = size * size * 4;\r\n\t\tconst data = new Uint8Array( arraySize );\r\n\r\n\t\tfor ( let i = 0; i < size; i ++ ) {\r\n\r\n\t\t\tfor ( let j = 0; j < size; j ++ ) {\r\n\r\n\t\t\t\tconst x = i;\r\n\t\t\t\tconst y = j;\r\n\r\n\t\t\t\tdata[ ( i * size + j ) * 4 ] = ( simplex.noise( x, y ) * 0.5 + 0.5 ) * 255;\r\n\t\t\t\tdata[ ( i * size + j ) * 4 + 1 ] = ( simplex.noise( x + size, y ) * 0.5 + 0.5 ) * 255;\r\n\t\t\t\tdata[ ( i * size + j ) * 4 + 2 ] = ( simplex.noise( x, y + size ) * 0.5 + 0.5 ) * 255;\r\n\t\t\t\tdata[ ( i * size + j ) * 4 + 3 ] = ( simplex.noise( x + size, y + size ) * 0.5 + 0.5 ) * 255;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst noiseTexture = new DataTexture( data, size, size, RGBAFormat, UnsignedByteType );\r\n\t\tnoiseTexture.wrapS = RepeatWrapping;\r\n\t\tnoiseTexture.wrapT = RepeatWrapping;\r\n\t\tnoiseTexture.needsUpdate = true;\r\n\r\n\t\treturn noiseTexture;\r\n\r\n\t}\r\n\r\n}\r\n\r\nGTAOPass.OUTPUT = {\r\n\t'Off': - 1,\r\n\t'Default': 0,\r\n\t'Diffuse': 1,\r\n\t'Depth': 2,\r\n\t'Normal': 3,\r\n\t'AO': 4,\r\n\t'Denoise': 5,\r\n};\r\n\r\nexport { GTAOPass };\r\n"],
  "mappings": "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A,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAC7H,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAC7H,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAC7H,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAC7H,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG,CAAE,GAAG,GAAG,GAAG,CAAE;AAAA,MAAG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",
  "names": []
}
